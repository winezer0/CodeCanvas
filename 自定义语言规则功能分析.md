# CodeCanvas 自定义语言规则分析

## 概述

CodeCanvas 提供了自定义语言规则功能，允许用户通过 `lang-rules.json` 文件定义特定语言的分类规则和行为特征。这些规则会覆盖或补充内置的语言分类逻辑。

## 规则文件位置

自定义规则文件应放置在项目根目录下，文件名为 `lang-rules.json`：
```
项目根目录/
├── lang-rules.json  # 自定义规则文件
├── src/
├── package.json
└── ...
```

## 规则文件格式

### 基本结构

```json
[
  {
    "name": "语言名称",
    "category": "分类",
    "features": {
      "name": "语言名称",
      "tokens": ["关键字1", "关键字2"],
      "file_patterns": ["**/*.ext", "**/*.custom"],
      "dependencies": ["依赖包1", "依赖包2"]
    }
  }
]
```

### 字段说明

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| name | string | 是 | 语言名称，用于标识语言 |
| category | string | 是 | 语言分类："frontend", "backend", "desktop" |
| features | object | 否 | 语言特征定义 |
| features.tokens | array | 否 | 语言关键字列表 |
| features.file_patterns | array | 否 | 文件模式匹配规则 |
| features.dependencies | array | 否 | 依赖包名称，用于分类判断 |

## 内置分类逻辑

### 默认分类集合

系统在 `internal/model/types.go` 中定义了默认的语言分类：

```go
var FrontendLanguageSet = map[string]bool{
    "JavaScript": true, "TypeScript": true, "JSX": true, "TSX": true,
    "HTML": true, "CSS": true, "SCSS": true, "Less": true,
    "Vue": true, "Angular": true, "React": true,
}

var BackendLanguageSet = mapstring]bool{
    "Java": true, "Python": true, "Go": true, "Rust": true,
    "C++": true, "C": true, "C#": true, "PHP": true,
    "Ruby": true, "Kotlin": true, "Scala": true,
}
```

### 分类优先级

1. **自定义规则**：最高优先级，覆盖所有其他逻辑
2. **依赖分析**：检查 package.json 中的依赖包
3. **文件模式**：匹配特定文件模式
4. **默认集合**：使用内置的语言分类集合

## 依赖分析逻辑

对于 JavaScript/TypeScript 语言，系统会分析 `package.json` 文件中的依赖包：

### 前端框架依赖
- `react`, `vue`, `@angular/core`, `next`, `nuxt`

### 后端框架依赖  
- `express`, `koa`, `nestjs`, `fastify`, `hapi`

### 分类判断逻辑

```go
if deps["react"] || deps["vue"] || deps["@angular/core"] {
    return "frontend"
}
if deps["express"] || deps["koa"] || deps["nestjs"] {
    return "backend"
}
```

## 文件模式匹配

系统支持使用 glob 模式匹配文件：

```go
"file_patterns": ["**/*.jsx", "**/*.tsx", "src/**/*.custom"]
```

匹配逻辑：
```go
matches, _ := filepath.Glob(filepath.Join(root, pattern))
if len(matches) > 0 {
    // 根据语言名称包含的关键字判断分类
    if strings.Contains(name, "jsx") || strings.Contains(name, "tsx") {
        return "frontend"
    }
    return "backend"
}
```

## 自定义规则示例

### 示例1：自定义前端框架语言

```json
[
  {
    "name": "Svelte",
    "category": "frontend",
    "features": {
      "file_patterns": ["**/*.svelte", "**/*.svx"],
      "dependencies": ["svelte", "@sveltejs/kit"]
    }
  }
]
```

### 示例2：自定义配置文件语言

```json
[
  {
    "name": "YAML",
    "category": "backend",
    "features": {
      "file_patterns": ["**/*.yml", "**/*.yaml", "**/docker-compose.*"]
    }
  }
]
```

### 示例3：自定义DSL语言

```json
[
  {
    "name": "GraphQL",
    "category": "backend",
    "features": {
      "file_patterns": ["**/*.graphql", "**/*.gql"],
      "dependencies": ["graphql", "apollo-server"]
    }
  }
]
```

### 示例4：多规则组合

```json
[
  {
    "name": "Python",
    "category": "backend",
    "features": {
      "dependencies": ["django", "flask", "fastapi"]
    }
  },
  {
    "name": "JavaScript",
    "category": "frontend",
    "features": {
      "dependencies": ["react", "vue", "angular"],
      "file_patterns": ["**/*.jsx", "**/*.tsx"]
    }
  },
  {
    "name": "TypeScript",
    "category": "backend",
    "features": {
      "dependencies": ["express", "nestjs", "koa"],
      "file_patterns": ["**/*.ts", "src/server/**/*"]
    }
  }
]
```

## 使用场景

### 场景1：覆盖默认分类

当系统默认分类不符合项目实际情况时，可以通过自定义规则覆盖：

```json
[
  {
    "name": "JavaScript",
    "category": "backend"
  }
]
```

### 场景2：添加新语言支持

为系统不支持的新的语言或框架添加分类规则：

```json
[
  {
    "name": "SolidJS",
    "category": "frontend",
    "features": {
      "file_patterns": ["**/*.jsx", "**/*.tsx"],
      "dependencies": ["solid-js"]
    }
  }
]
```

### 场景3：细粒度项目分类

根据项目特点进行更细致的分类：

```json
[
  {
    "name": "Python",
    "category": "backend",
    "features": {
      "dependencies": ["django", "flask"]
    }
  },
  {
    "name": "Python",
    "category": "desktop",
    "features": {
      "dependencies": ["tkinter", "pyqt5", "wxpython"]
    }
  }
]
```

## 加载和使用流程

1. **规则加载**：`LoadFromFile()` 方法尝试加载 `lang-rules.json`
2. **规则合并**：自定义规则与内置规则合并，自定义规则优先级更高
3. **语言检测**：`DetectCategories()` 方法根据规则对检测到的语言进行分类
4. **结果返回**：返回前端、后端、桌面和全部语言的分类结果

## 错误处理

- 如果规则文件不存在，系统会静默忽略，使用内置规则
- 如果规则文件格式错误，会返回错误，但不会影响基本功能
- 规则名称不区分大小写，系统会自动转换为小写处理

## 最佳实践

1. **最小化规则**：只定义需要覆盖或新增的规则
2. **明确分类**：确保分类准确，避免歧义
3. **测试验证**：创建规则后测试分类结果是否符合预期
4. **文档维护**：为复杂规则添加注释说明
5. **版本控制**：将 `lang-rules.json` 纳入版本控制，便于团队协作

## 扩展性

该规则系统设计具有良好的扩展性，可以轻松添加：
- 新的分类标准
- 更多的特征类型
- 复杂的匹配逻辑
- 多层次的规则优先级

通过合理使用自定义规则，可以显著提高 CodeCanvas 对项目的语言分类准确性。