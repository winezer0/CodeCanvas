# LangJSON 规则文件格式详细文档

## 概述

LangJSON 是 CodeCanvas 项目中用于定义自定义语言分类规则的 JSON 配置文件格式。通过编写 LangJSON 规则文件，用户可以扩展和自定义编程语言的检测和分类逻辑。

## 文件结构

LangJSON 文件是一个 JSON 数组，包含一个或多个语言规则对象：

```json
[
  {
    "name": "语言名称",
    "category": "分类",
    "features": {
      "name": "语言名称",
      "tokens": ["关键字1", "关键字2"],
      "file_patterns": ["**/*.ext", "**/*.custom"],
      "dependencies": ["依赖包1", "依赖包2"]
    }
  }
]
```

## 字段详解

### 1. 顶层字段

#### `name` (字符串, 必填)
- **描述**: 编程语言的名称
- **用途**: 作为主标识符，用于在分类结果中显示
- **格式**: 建议使用正式的语言名称，如 "TypeScript"、"Rust"
- **示例**: `"name": "Svelte"`

#### `category` (字符串, 必填)
- **描述**: 语言的分类类别
- **可选值**: 
  - `"frontend"`: 前端开发语言   // 常用
  - `"backend"`: 后端开发语言    // 常用
  - `"desktop"`: 桌面应用开发语言 // 已使用
  - `"mobile"`: 移动开发语言 // 实际未使用
  - `"devops"`: 运维和部署相关语言 // 实际未使用
  - `"data"`: 数据科学和分析语言 // 实际未使用
  - `"other"`: 其他类别 // 实际未使用
- **用途**: 决定语言在项目架构中的分类
- **示例**: `"category": "frontend"`

#### `features` (对象, 必填)
- **描述**: 包含语言特征检测规则的详细配置
- **用途**: 定义如何识别和验证该语言的存在
- **结构**: 包含多个子字段的对象

### 2. Features 子字段

#### `name` (字符串, 可选)
- **描述**: 语言的显示名称
- **用途**: 如果提供，会覆盖顶层 `name` 字段用于显示
- **默认值**: 使用顶层 `name` 字段的值
- **示例**: `"name": "Vue.js"`

#### `tokens` (数组, 可选)
- **描述**: 用于语法高亮和代码识别的关键字列表
- **用途**: 在代码分析时识别语言特征
- **格式**: 字符串数组，包含该语言的特有语法元素
- **示例**: 
```json
"tokens": ["import", "export", "const", "let", "async", "await"]
```

#### `file_patterns` (数组, 可选)
- **描述**: 文件路径匹配模式
- **用途**: 通过文件扩展名和路径模式识别语言
- **格式**: glob 模式字符串数组
- **通配符**:
  - `**`: 匹配任意层级的目录
  - `*`: 匹配任意字符（不含路径分隔符）
  - `?`: 匹配单个字符
- **示例**:
```json
"file_patterns": [
  "**/*.svelte",
  "**/*.svx",
  "**/svelte.config.js"
]
```

#### `dependencies` (数组, 可选)
- **描述**: 该语言项目常见的依赖包名称
- **用途**: 通过 package.json、requirements.txt 等依赖文件识别语言
- **格式**: 字符串数组，包含包管理器中的包名
- **示例**:
```json
"dependencies": [
  "svelte",
  "@sveltejs/kit",
  "svelte-preprocess",
  "rollup-plugin-svelte"
]
```

## 完整示例

### 前端框架示例

```json
{
  "name": "Svelte",
  "category": "frontend",
  "features": {
    "name": "Svelte",
    "tokens": ["script", "style", "svelte:", "on:", "bind:"],
    "file_patterns": [
      "**/*.svelte",
      "**/*.svx",
      "**/svelte.config.js",
      "**/rollup.config.js"
    ],
    "dependencies": [
      "svelte",
      "@sveltejs/kit",
      "svelte-preprocess",
      "rollup-plugin-svelte"
    ]
  }
}
```

### 后端技术示例

```json
{
  "name": "GraphQL",
  "category": "backend",
  "features": {
    "name": "GraphQL",
    "tokens": ["type", "Query", "Mutation", "Subscription", "schema"],
    "file_patterns": [
      "**/*.graphql",
      "**/*.gql",
      "**/schema.graphql",
      "**/schema.gql"
    ],
    "dependencies": [
      "graphql",
      "apollo-server",
      "graphql-yoga",
      "mercurius",
      "type-graphql"
    ]
  }
}
```

### 开发工具示例

```json
{
  "name": "Docker",
  "category": "devops",
  "features": {
    "name": "Docker",
    "tokens": ["FROM", "RUN", "CMD", "EXPOSE", "ENV", "COPY"],
    "file_patterns": [
      "**/Dockerfile",
      "**/Dockerfile.*",
      "**/docker-compose.yml",
      "**/docker-compose.yaml",
      "**/.dockerignore"
    ],
    "dependencies": [
      "docker",
      "docker-compose"
    ]
  }
}
```

## 最佳实践

### 1. 文件模式设计
- **使用具体的扩展名**: 优先使用标准的文件扩展名
- **包含配置文件**: 考虑框架特有的配置文件
- **避免过于宽泛的模式**: 防止误识别

```json
// 好的实践
"file_patterns": ["**/*.vue", "**/vue.config.js"]

// 避免
"file_patterns": ["**/*.js"]  // 太宽泛，会匹配所有JavaScript文件
```

### 2. 依赖项选择
- **选择核心依赖**: 使用该语言/框架的核心包
- **避免过度指定**: 不要包含可选的或工具相关的依赖
- **考虑生态系统**: 包含主流的工具和库

```json
// React 示例 - 好的实践
"dependencies": [
  "react",
  "react-dom",
  "@types/react"
]

// 避免包含可选工具
"dependencies": [
  "react",
  "react-dom", 
  "eslint-plugin-react",  // 这是可选的开发工具
  "react-test-renderer"   // 这是测试工具
]
```

### 3. 分类选择
- **根据主要用途分类**: 基于语言的主要应用场景
- **考虑项目角色**: 在典型项目中的使用位置
- **保持一致性**: 遵循已有的分类约定

```json
// TypeScript 通常用于前端
{
  "name": "TypeScript",
  "category": "frontend",
  "features": { /* ... */ }
}

// 但如果主要用于Node.js后端
{
  "name": "TypeScript",
  "category": "backend", 
  "features": { /* ... */ }
}
```

## 验证和调试

### 1. JSON 格式验证
使用 JSON 验证工具确保格式正确：

```bash
# 使用 jq 验证
jq empty your-rules.json

# 使用 Python 验证
python -m json.tool your-rules.json
```


## 常见模式

### 多文件类型支持
```json
{
  "name": "Python",
  "category": "backend",
  "features": {
    "file_patterns": [
      "**/*.py",
      "**/*.pyw",
      "**/requirements.txt",
      "**/setup.py",
      "**/pyproject.toml"
    ]
  }
}
```

### 配置驱动语言
```json
{
  "name": "Webpack",
  "category": "frontend",
  "features": {
    "file_patterns": [
      "**/webpack.config.js",
      "**/webpack.config.ts",
      "**/webpack.*.js"
    ],
    "dependencies": [
      "webpack",
      "webpack-cli",
      "webpack-dev-server"
    ]
  }
}
```

### 标记语言
```json
{
  "name": "Markdown",
  "category": "other",
  "features": {
    "file_patterns": [
      "**/*.md",
      "**/*.markdown",
      "**/*.mdx",
      "**/README*",
      "**/CHANGELOG*"
    ]
  }
}
```

## 版本兼容性

LangJSON 格式设计为向前兼容：
- 新字段可以被添加而不会破坏现有实现
- 未知字段会被忽略
- 缺少可选字段会使用合理的默认值

## 性能考虑

- **限制规则数量**: 大量规则可能影响分析性能
- **优化文件模式**: 复杂的 glob 模式可能降低匹配速度
- **缓存结果**: CodeCanvas 会缓存规则解析结果以提高性能

## 总结

LangJSON 提供了一个灵活而强大的方式来扩展 CodeCanvas 的语言检测能力。通过合理设计文件模式、依赖项和分类，可以准确识别项目中的各种技术和工具。遵循最佳实践可以确保规则的准确性和可维护性。